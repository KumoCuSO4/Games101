240127

旋转矩阵和透视矩阵

MVP: model view projection （模型 视图 投影）

### 视图变换View（模型视图变换ModelView）

根据相机的位置和角度进行变换，让相机转到**以-Z为方向，Y为上的角度，且相机位置为原点**（默认是右手系）。让其他物体进行相同的变换，让相机中看到的结果不变。以下图为参考：

![image-20240127161630107](./计算机图形学.assets/image-20240127161630107.png)

**平移操作**比较容易，直接写成这个形式：

![image-20240127161740163](./计算机图形学.assets/image-20240127161740163.png)

**旋转操作**会难一点直接考虑g到-Z，t到Y，(g×t)到X会比较困难，但是反过来的计算更加简单（下图的R^-1^如果乘以X（1，0，0，0）、Y（0，1，0，0）、-Z（0，0，-1，0）得到的分别是(g×t)、t、g），对反过来的矩阵求一个逆矩阵就是我们需要的旋转变换矩阵。**旋转矩阵是正交矩阵，因此他的逆就是他的转置**。

![image-20240127161826141](./计算机图形学.assets/image-20240127161826141.png)

### 投影变换Projection

正交投影 透视投影（近大远小）

#### 正交投影Orthographic projection

**简单理解，并非实际做法：**

![image-20240127165931887](./计算机图形学.assets/image-20240127165931887.png)

因为相机是朝向-Z方向，简单的方式是拿掉Z轴（依然要区分物体的前后），然后缩放到[-1,1]*[-1,1]的矩形中（约定俗成的，为了方便后续计算）。

**实际做法：**

![image-20240127173147151](./计算机图形学.assets/image-20240127173147151.png)

一个空间中的长方体，**在X轴的左右lr，在Y轴的下上bt，在Z轴的远近fn，映射到[-1,1]^3^的正则（也叫规范、标准）立方体中**。（注意远的Z轴小，近的Z轴大，也就是近大于远，因为是-Z的方向。OpenGL会使用左手系来让他变成远大于近，但也会有X×Y不等于Z的问题，左右手系各有好坏）

变换过程，**先平移来移动中心到原点，再对三个轴上的尺寸进行缩放**，如下图所示。

![image-20240127174138842](./计算机图形学.assets/image-20240127174138842.png)

#### 透视投影Perspective projection

透视投影将一个四棱锥（frustum）挤压为长方体，然后再用正交投影的方法。

![image-20240127191412891](./计算机图形学.assets/image-20240127191412891.png)

**挤压的过程**：首先我们规定：近平面的每个点不变，远平面每个点的Z不变，远平面的中心点不变（为什么）。任意点(x, y, z)映射到近平面z=-n的点(x', y', z')，那么挤压后的x=x'，y=y'，通过相似三角形知道每个点的X和Y该如何变化。(0>n>z>f)

![image-20240127191657918](./计算机图形学.assets/image-20240127191657918.png)

![image-20240127192225944](./计算机图形学.assets/image-20240127192225944.png)

可知挤压后的点为(nx, ny, ?, z)，不过此时我们只知道x和y如何变化，并不知道z如何变化（z并不是不变的），根据之前的定义近平面点不变，远平面z不变可以用来求出第三行的变化。

240128

![image-20240128141018960](./计算机图形学.assets/image-20240128141018960.png)

![image-20240128141342986](./计算机图形学.assets/image-20240128141342986.png)

对于近平面的点(x, y, n, 1)变化之后等于自身也就是(nx, ny, n^2^, n)，n^2^是与x和y无关的数，所以可以得出上图所示的式子An+B=n^2^。又因为远平面中心点(0, 0, f, 1)在挤压后位置不变，得到上图的第二个式子Af+B=f^2^。

最终解出AB

![image-20240128165333412](./计算机图形学.assets/image-20240128165333412.png)

第三行也就是Az+B = (n+f)*z-nf   0>n>z>f

z'-z = k     f^2^-f>k>n^2^-n>0    z'>z   可知挤压后更靠近近平面
$$
透视投影到正交投影的转换M_{p2o} = \begin{pmatrix} n & 0 & 0 & 0 \\ 0 & n & 0 & 0 \\ 0 & 0 & n+f & -nf \\ 0 & 0 & 1 & 0 \end{pmatrix}
$$


#### FoV Field of View

![image-20240128192206265](./计算机图形学.assets/image-20240128192206265.png)

![image-20240128192300720](./计算机图形学.assets/image-20240128192300720.png)

竖直方向上的fovY为近平面上下中点与相机位置的夹角，也就是2arctan(t/|n|)，宽高比aspect=r/t

### 视口变换Viewport

将之前得到的[-1,1]^3^的立方体进行缩放，符合屏幕的分辨率

![image-20240128202319336](./计算机图形学.assets/image-20240128202319336.png)

![image-20240128202924575](./计算机图形学.assets/image-20240128202924575.png)

### 光栅化Rasterization

![image-20240128202840445](./计算机图形学.assets/image-20240128202840445.png)

解决将三角形转换为像素应当如何转换的问题。

最简单的方法：采样Sampling，判断像素中心在三角形内。

通过叉积，如果点与三个边的向量同侧就是在内部（都是顺时针或逆时针）

![image-20240128210321929](./计算机图形学.assets/image-20240128210321929.png)

采样点位于边界上的情况，要么不做处理，要么就进行特殊处理，可以自己定义。在OpenGL中规定了左上在内，右下在外。

![image-20240128210558582](./计算机图形学.assets/image-20240128210558582.png)

优化方案，不用检查屏幕中的每个像素，只需要检查上图蓝色区域中的像素，称为包围盒（Bounding Box）。判断x和y的最大最小值确定蓝色区域。

![image-20240130212000534](./计算机图形学.assets/image-20240130212000534.png)

其他的优化方案：计算每一行的左右端点，保证不会计算多余的点，适用于细长的、斜对角的三角形

240202

### 走样Aliasing

采样可能存在问题：锯齿、摩尔纹、车轮效应。本质上是因为信号变换太快了。

解决方法：在采样之前进行模糊（滤波）

要先模糊再采样

同样的采样方法去采两个截然不同的函数，可能得到相同的结果

频域FrequencyDomain

240217

240218

Convolution in the spatial domain is equal to multiplication in the frequency domain, and vice versa

实域中的卷积 = 频域中的乘积

![image-20240218214032560](./计算机图形学.assets/image-20240218214032560.png)

采样 = 重复频率内容

走样 = 混合的频率内容

![image-20240218214116476](./计算机图形学.assets/image-20240218214116476.png)

这段听不太懂

### 反走样（抗锯齿）

可以通过增加采样率，或者使用反走样的算法（比如采样前过滤掉高频率），以减少走样。

#### MSAA

在一个像素内使用多个采样点（比如4*4），对颜色取平均值。

缺点在于开销会很大，如果一个像素内有非常多的采样点，计算量指数级增加。

![image-20240218214800121](./计算机图形学.assets/image-20240218214800121.png)

#### FXAA (Fast Approximate AA)

不增加采样，对采样后的图像进行后期处理，分析边界，将边界换成没有锯齿的边界。

#### TAA (Temporal AA)

根据上一帧进行分析，复用上一帧的结果。

### 超分辨率/超采样

#### DLSS (Deep Learning Super Sampling)

利用深度学习对低分辨率的图像猜出更高的分辨率。

